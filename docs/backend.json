
{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user in the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "username": {
          "type": "string",
          "description": "User's username."
        },
        "fullName": {
          "type": "string",
          "description": "User's full name."
        },
        "email": {
          "type": "string",
          "description": "User's email address.",
          "format": "email"
        },
        "bio": {
          "type": "string",
          "description": "User's biography."
        },
        "profilePhoto": {
          "type": "string",
          "description": "URL of the user's profile photo.",
          "format": "uri"
        },
        "followers": {
          "type": "array",
          "description": "References to Users who are following this user. (Relationship: User N:N User)",
          "items": {
            "type": "string"
          }
        },
        "following": {
          "type": "array",
          "description": "References to Users who this user is following. (Relationship: User N:N User)",
          "items": {
            "type": "string"
          }
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the user was created.",
          "format": "date-time"
        },
        "verified": {
          "type": "boolean",
          "description": "Indicates if the user's account is verified."
        }
      },
      "required": [
        "id",
        "username",
        "email",
        "createdAt"
      ]
    },
    "Post": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Post",
      "type": "object",
      "description": "Represents a post in the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the post."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Post)"
        },
        "imageUrl": {
          "type": "string",
          "description": "URL of the post's image.",
          "format": "uri"
        },
        "caption": {
          "type": "string",
          "description": "Caption for the post."
        },
        "location": {
          "type": "string",
          "description": "Location where the post was taken."
        },
        "likes": {
          "type": "array",
          "description": "References to Users who liked this post. (Relationship: User N:N Post)",
          "items": {
            "type": "string"
          }
        },
        "commentsCount": {
          "type": "number",
          "description": "Number of comments on the post."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the post was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "imageUrl",
        "createdAt"
      ]
    },
    "Story": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Story",
      "type": "object",
      "description": "Represents a story in the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the story."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Story)"
        },
        "mediaUrl": {
          "type": "string",
          "description": "URL of the story's media (image or video).",
          "format": "uri"
        },
        "type": {
          "type": "string",
          "description": "Type of the story media (image or video)."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the story was created.",
          "format": "date-time"
        },
        "expiresAt": {
          "type": "string",
          "description": "Timestamp of when the story expires.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "mediaUrl",
        "type",
        "createdAt",
        "expiresAt"
      ]
    },
    "Reel": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Reel",
      "type": "object",
      "description": "Represents a reel in the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the reel."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Reel)"
        },
        "videoUrl": {
          "type": "string",
          "description": "URL of the reel's video.",
          "format": "uri"
        },
        "thumbnailUrl": {
          "type": "string",
          "description": "URL of the reel's thumbnail.",
          "format": "uri"
        },
        "likes": {
          "type": "array",
          "description": "References to Users who liked this reel. (Relationship: User N:N Reel)",
          "items": {
            "type": "string"
          }
        },
        "commentsCount": {
          "type": "number",
          "description": "Number of comments on the reel."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the reel was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "videoUrl",
        "thumbnailUrl",
        "createdAt"
      ]
    },
    "Comment": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Comment",
      "type": "object",
      "description": "Represents a comment on a post or reel.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the comment."
        },
        "parentId": {
          "type": "string",
          "description": "Reference to Post or Reel to which the comment belongs."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User who wrote the comment. (Relationship: User 1:N Comment)"
        },
        "text": {
          "type": "string",
          "description": "Text content of the comment."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the comment was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "parentId",
        "userId",
        "text",
        "createdAt"
      ]
    },
    "Chat": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Chat",
      "type": "object",
      "description": "Represents a chat between two users.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the chat."
        },
        "users": {
          "type": "array",
          "description": "References to Users participating in the chat. (Relationship: User N:N Chat)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "users"
      ]
    },
    "Message": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Message",
      "type": "object",
      "description": "Represents a message within a chat.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the message."
        },
        "chatId": {
          "type": "string",
          "description": "Reference to Chat to which the message belongs. (Relationship: Chat 1:N Message)"
        },
        "senderId": {
          "type": "string",
          "description": "Reference to User who sent the message. (Relationship: User 1:N Message)"
        },
        "text": {
          "type": "string",
          "description": "Text content of the message.  If mediaUrl is populated, this will contain the AI generated caption."
        },
        "mediaUrl": {
          "type": "string",
          "description": "URL of the message's media (image or video), can be null.",
          "format": "uri"
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of when the message was sent.",
          "format": "date-time"
        },
        "isRead": {
          "type": "boolean",
          "description": "Indicates if the message has been read."
        }
      },
      "required": [
        "id",
        "chatId",
        "senderId",
        "timestamp",
        "isRead"
      ]
    },
    "Call": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Call",
      "type": "object",
      "description": "Represents a call between two users.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the call."
        },
        "callerId": {
          "type": "string",
          "description": "Reference to User who initiated the call. (Relationship: User 1:N Call)"
        },
        "receiverId": {
          "type": "string",
          "description": "Reference to User who received the call. (Relationship: User 1:N Call)"
        },
        "offer": {
          "type": "string",
          "description": "SDP offer for the call."
        },
        "answer": {
          "type": "string",
          "description": "SDP answer for the call."
        },
        "candidates": {
          "type": "array",
          "description": "ICE candidates for the call.",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "callerId",
        "receiverId"
      ]
    },
    "Stream": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Stream",
      "type": "object",
      "description": "Represents a live stream session.",
      "properties": {
        "id": { "type": "string", "description": "Unique identifier for the stream." },
        "title": { "type": "string", "description": "Title of the stream." },
        "streamerName": { "type": "string", "description": "Username of the streamer." },
        "streamerId": { "type": "string", "description": "User ID of the streamer." },
        "avatarUrl": { "type": "string", "format": "uri", "description": "URL to the streamer's avatar." },
        "category": { "type": "string", "description": "Category of the stream (e.g., 'Just Chatting')." },
        "viewerCount": { "type": "number", "description": "Current number of viewers." },
        "isLive": { "type": "boolean", "description": "Indicates if the stream is currently live." },
        "thumbnailUrl": { "type": "string", "format": "uri", "description": "URL for the stream's thumbnail." },
        "tags": { "type": "array", "items": { "type": "string" }, "description": "Tags associated with the stream." }
      },
      "required": ["id", "title", "streamerName", "streamerId", "category", "viewerCount", "isLive"]
    },
    "Category": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Category",
      "type": "object",
      "description": "Represents a content category for streams.",
      "properties": {
        "id": { "type": "string", "description": "Unique identifier for the category." },
        "name": { "type": "string", "description": "Name of the category." },
        "thumbnailUrl": { "type": "string", "format": "uri", "description": "URL for the category's box art." }
      },
      "required": ["id", "name", "thumbnailUrl"]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information. Path-based ownership ensures only the user can modify their profile.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "posts/{postId}",
        "definition": {
          "entityName": "Post",
          "schema": {
            "$ref": "#/backend/entities/Post"
          },
          "description": "Stores posts. Includes userId for ownership and supports listing all posts.",
          "params": [
            {
              "name": "postId",
              "description": "The unique identifier of the post."
            }
          ]
        }
      },
      {
        "path": "stories/{storyId}",
        "definition": {
          "entityName": "Story",
          "schema": {
            "$ref": "#/backend/entities/Story"
          },
          "description": "Stores stories with userId for ownership and supports listing stories based on expiration.",
          "params": [
            {
              "name": "storyId",
              "description": "The unique identifier of the story."
            }
          ]
        }
      },
      {
        "path": "reels/{reelId}",
        "definition": {
          "entityName": "Reel",
          "schema": {
            "$ref": "#/backend/entities/Reel"
          },
          "description": "Stores reels with userId for ownership and supports listing reels.",
          "params": [
            {
              "name": "reelId",
              "description": "The unique identifier of the reel."
            }
          ]
        }
      },
      {
        "path": "comments/{commentId}",
        "definition": {
          "entityName": "Comment",
          "schema": {
            "$ref": "#/backend/entities/Comment"
          },
          "description": "Stores comments with parentId referencing the post or reel and userId indicating the author.",
          "params": [
            {
              "name": "commentId",
              "description": "The unique identifier of the comment."
            }
          ]
        }
      },
      {
        "path": "chats/{chatId}",
        "definition": {
          "entityName": "Chat",
          "schema": {
            "$ref": "#/backend/entities/Chat"
          },
          "description": "Stores chat metadata, including the users array for authorization.",
          "params": [
            {
              "name": "chatId",
              "description": "The unique identifier of the chat."
            }
          ]
        }
      },
      {
        "path": "chats/{chatId}/messages/{messageId}",
        "definition": {
          "entityName": "Message",
          "schema": {
            "$ref": "#/backend/entities/Message"
          },
          "description": "Stores messages within a chat. Authorization is based on chat membership.",
          "params": [
            {
              "name": "chatId",
              "description": "The unique identifier of the chat."
            },
            {
              "name": "messageId",
              "description": "The unique identifier of the message."
            }
          ]
        }
      },
      {
        "path": "calls/{callId}",
        "definition": {
          "entityName": "Call",
          "schema": {
            "$ref": "#/backend/entities/Call"
          },
          "description": "Stores call metadata for WebRTC signaling. Security rules restrict access to the caller and receiver.",
          "params": [
            {
              "name": "callId",
              "description": "The unique identifier of the call."
            }
          ]
        }
      },
      {
        "path": "streams/{streamId}",
        "definition": {
          "entityName": "Stream",
          "schema": {
            "$ref": "#/backend/entities/Stream"
          },
          "description": "Stores live stream data. Publicly readable, but only writable by the streamer.",
          "params": [
            {
              "name": "streamId",
              "description": "The unique identifier for the stream."
            }
          ]
        }
      },
      {
        "path": "categories/{categoryId}",
        "definition": {
          "entityName": "Category",
          "schema": {
            "$ref": "#/backend/entities/Category"
          },
          "description": "Stores content categories for streams. Generally read-only for clients.",
          "params": [
            {
              "name": "categoryId",
              "description": "The unique identifier for the category."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to create a scalable and secure Instagram-like application, named YC, prioritizing authorization independence, clarity, and ease of maintenance. The structure segregates data based on access patterns and uses denormalization to avoid complex security rules using `get()` calls. \n\n*   **users/{userId}:**  Path-based ownership ensures only the user can modify their profile. Includes core profile information (username, email, bio, profilePhoto, followers, following, createdAt, verified).\n*   **posts/{postId}:**  Each post is stored in a top-level collection. `userId` indicates ownership. This approach facilitates listing all posts, potentially filtered by user. Includes: userId, imageUrl, caption, location, likes(array), commentsCount, createdAt.  Security rules will enforce that a user can only write posts with their own `userId`.\n*   **stories/{storyId}:**  Each story is stored in a top-level collection to facilitate listing and querying based on expiration (`expiresAt`). The `userId` field denotes ownership. Includes userId, mediaUrl, type(image/video), createdAt, expiresAt.\n*   **reels/{reelId}:** Each reel is stored in a top-level collection to facilitate listing and querying. `userId` indicates ownership. Includes userId, videoUrl, thumbnailUrl, likes(array), commentsCount, createdAt. Security rules will enforce that a user can only write reels with their own `userId`.\n*   **comments/{commentId}:** Each comment is stored in a top-level collection, simplifying queries across posts and reels. `parentId` references either a `postId` or `reelId`.  The `userId` field indicates the comment's author. Includes parentId(postId or reelId), userId, text, createdAt.\n*   **chats/{chatId}:** Represents a chat between two users. The `users` array contains the UIDs of the participants. Includes users: [userId1, userId2].\n*   **chats/{chatId}/messages/{messageId}:** Subcollection of `chats`. Each message contains `senderId`, `text` or `mediaUrl`, `timestamp`, and `isRead`.  Authorization rules will ensure only participants can read messages.\n*   **calls/{callId}:**  Each document stores call metadata for WebRTC signaling, including `callerId`, `receiverId`, SDP `offer`, and `answer`. Security rules restrict access to the caller and receiver to ensure signaling is private.\n*   **streams/{streamId} & categories/{categoryId}**: Added collections for the live-streaming feature. `streams` will be publicly readable to populate the browse page, but write access will be restricted to the streamer. `categories` will be public and read-only for clients.\n\n**Authorization Independence (Denormalization):**\n\n*   The structure avoids `get()` calls in security rules by denormalizing authorization data.  For example, the `posts`, `stories`, `reels`, and `comments` collections all include the `userId` which allow rules to authorize create/update operations based on `request.auth.uid == resource.data.userId`. For chats, a user must be in the `users` array to read/write messages in that chat.\n\n**Query and List Security (QAPs):**\n\n*   The segregation of data into distinct collections (e.g., separating posts and reels) allows for simple `list` operations with straightforward security rules (e.g., `allow read: if request.auth != null`).\n*   The `users` array in `chats` enables secure listing of chats for a specific user (rule: `request.auth.uid in resource.data.users`).\n\nThis structure adheres to the core design principles by:\n\n*   Enabling authorization independence through denormalization.\n*   Providing clarity of intent through a well-defined, predictable schema.\n*   Avoiding custom claims (DBAC) and relying on `request.auth.uid`.\n*   Supporting secure `list` operations (QAPs) via structural segregation and membership maps.\n*   Facilitating the enforcement of data invariants such as ownership and timestamps."
  }
}

    